<!DOCTYPE html>
<html>
<head>
    <title>프로그래밍: 커맨드 패턴의 개념 및 활용 예시</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: black;
        }

        .blog {
            width: 70%;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.1);
        }

        .blog h1 {
            color: #333333;
            font-size: 2em;
            margin-bottom: 20px;
        }

        .blog p, .blog pre {
            color: #666666;
            line-height: 1.6;
            font-size: 1em;
            margin-bottom: 15px;
        }

        .blog code {
            background-color: yellow;
            color: black;
            font-family: Consolas, monospace;
        }

        .blog pre {
            background-color: black;
            padding: 10px;
            border-radius: 5px;
            overflow: auto;
            color: #00FF00;
        }

        .blog ul {
            list-style-type: disc;
            margin-left: 20px;
        }

        footer {
            color: #999999;
            font-size: 0.8em;
            text-align: right;
            margin-top: 20px;
        }

        footer a {
            color: #999999;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Animation */
        .blog {
            background-image: radial-gradient(circle at center, green 10%, transparent 30%);
            background-repeat: no-repeat;
            background-position: center;
            background-size: 0% 0%;
            transition: background-size 0.5s;
        }

        .blog:hover {
            background-size: 100% 100%;
        }
    </style>
</head>
<body>
    <div class="blog">
        <h1>프로그래밍: 커맨드 패턴의 개념 및 활용 예시</h1>
        <p>커맨드 패턴은 객체 지향 프로그래밍에서 행동 디자인 패턴 중 하나입니다. 이 패턴은 요청 자체를 객체화함으로써 클라이언트와 수신자를 분리합니다. 이것은 다양한 명령, 큐, 요청 및 연산을 객체로 만들고 수신자와 호출 정보를 함께 저장하여 나중에 연산을 수행할 수 있도록 합니다. 커맨드 패턴은 재사용이 가능하며 연산과 그 호출 정보를 저장해 두었다가 적절한 시기에 수행하거나 취소하는 등의 기능을 수행합니다.</p>
        <pre>
public interface ICommand
{
    void Execute();
}

public class JumpCommand : ICommand
{
    private Player _player;
    
    public JumpCommand(Player player)
    {
        _player = player;
    }

    public void Execute()
    {
        _player.Jump();
    }
}

public class Player
{
    public void Jump()
    {
        Debug.Log("Player jumped!");
    }
}

public class InputHandler
{
    private ICommand _jumpCommand;

    public InputHandler(Player player)
    {
        _jumpCommand = new JumpCommand(player);
    }

    public void HandleInput()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            _jumpCommand.Execute();
        }
    }
}
        </pre>
        <p>위의 C# 코드 예시에서, <code>JumpCommand</code> 클래스는 <code>ICommand</code> 인터페이스를 구현합니다. 이 클래스의 <code>Execute()</code> 메소드는 <code>Player</code>의 <code>Jump()</code> 메소드를 호출합니다. <code>InputHandler</code> 클래스는 사용자의 입력을 처리하고, 스페이스 키가 눌리면 <code>JumpCommand</code>를 실행합니다.</p>
        <p>커맨드 패턴을 사용하면 다음과 같은 장점이 있습니다:</p>
        <ul>
            <li>코드의 유연성을 높입니다: 클라이언트와 수신자를 분리하면, 수신자의 구현에 대해 클라이언트가 알 필요가 없습니다.</li>
            <li>코드 재사용성이 높아집니다: 같은 명령을 여러 곳에서 사용할 수 있습니다.</li>
            <li>연산을 취소하거나 재실행하는 기능을 구현하기 쉽습니다: 이전에 실행한 명령을 기록해 두었다가 취소하거나 재실행할 수 있습니다.</li>
        </ul>
        <p>그러나 커맨드 패턴에는 다음과 같은 단점도 있습니다:</p>
        <ul>
            <li>코드가 복잡해질 수 있습니다: 각 명령에 대해 클래스를 만들어야 하므로, 작은 프로젝트에서는 오버헤드가 클 수 있습니다.</li>
            <li>디버깅이 어려울 수 있습니다: 실행 흐름이 여러 클래스에 걸쳐 분산되므로, 코드를 따라가기가 어려울 수 있습니다.</li>
        </ul>
        <footer>
            <p>참고: <a href="https://en.wikipedia.org/wiki/Command_pattern">위키피디아</a></p>
        </footer>
    </div>
    
    <div id="popup" class="hidden">
    <img id="popup-img" src="">
</div>

</body>
</html>
